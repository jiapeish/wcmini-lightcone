"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-plusplus */
/* eslint-disable no-underscore-dangle */
let nodeIdIn;
let clockseqIn;
let lastMSecsIn = 0;
let lastNSecsIn = 0;
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
    byteToHex[i] = (i + 0x100).toString(16).substr(1);
}
const UUID = {
    bytesToUuid: (buf, noLine) => {
        let uuid = '';
        for (let i = 0; i < 16; i++) {
            uuid += byteToHex[buf[i]];
            if (!noLine && [3, 5, 7, 9].indexOf(i) !== -1) {
                uuid += '-';
            }
        }
        return uuid;
    },
    uuid: (noLine = false) => {
        let i = 0;
        const b = [];
        let node = nodeIdIn;
        let clockseq = clockseqIn;
        if (!node || !clockseq) {
            const seedBytes = `${Math.random()}`.substr(3, 19);
            if (!node) {
                nodeIdIn = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
                node = nodeIdIn;
            }
            if (!clockseq) {
                clockseqIn = ((seedBytes[6] << 8) | seedBytes[7]) & 0x3fff;
                clockseq = clockseqIn;
            }
        }
        let msecs = new Date().getTime();
        let nsecs = lastNSecsIn + 1;
        const dt = msecs - lastMSecsIn + (nsecs - lastNSecsIn) / 10000;
        if (dt < 0) {
            clockseq = (clockseq + 1) & 0x3fff;
        }
        if (dt < 0 || msecs > lastMSecsIn) {
            nsecs = 0;
        }
        if (nsecs >= 10000) {
            throw new Error("uuid: Can't create more than 10M uuids/sec");
        }
        lastMSecsIn = msecs;
        lastNSecsIn = nsecs;
        clockseqIn = clockseq;
        msecs += 12219292800000;
        // `time_low`
        const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
        b[i++] = (tl >>> 24) & 0xff;
        b[i++] = (tl >>> 16) & 0xff;
        b[i++] = (tl >>> 8) & 0xff;
        b[i++] = tl & 0xff;
        // `time_mid`
        const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;
        b[i++] = (tmh >>> 8) & 0xff;
        b[i++] = tmh & 0xff;
        // `time_high_and_version`
        b[i++] = ((tmh >>> 24) & 0xf) | 0x10; // include version
        b[i++] = (tmh >>> 16) & 0xff;
        // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
        b[i++] = (clockseq >>> 8) | 0x80;
        b[i++] = clockseq & 0xff;
        for (let n = 0; n < 6; ++n) {
            b[i + n] = node[n];
        }
        return UUID.bytesToUuid(b, noLine);
    },
    uuidWithoutLine: () => UUID.uuid(true),
};
exports.default = UUID;

"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAuthBaseConfig = void 0;
const common_1 = require("../../common");
const eventBus_1 = require("../../eventBus");
const storage_1 = require("../../storage");
async function processBaseRequestOptions(options, transferUrl = false) {
    // Objects must be copied to prevent modification of data such as body.
    const { url } = options, copyOptions = __rest(options, ["url"]);
    if (copyOptions.method === 'PATCH') {
        if (!copyOptions.headers) {
            copyOptions.headers = {};
        }
        copyOptions.headers['X-HTTP-Method-Override'] = 'PATCH';
        copyOptions.method = 'POST';
    }
    if (copyOptions.body && typeof copyOptions.body !== 'string') {
        copyOptions.body = JSON.stringify(copyOptions.body, (key, value) => {
            if (value && value !== '') {
                return value;
            }
        });
    }
    const path = (0, common_1.getUrlPath)(url);
    const sliceUrl = url.slice(0, url.indexOf(path));
    const [_, host] = sliceUrl.match(/:\/\/(.*)$/) || [sliceUrl, sliceUrl];
    copyOptions.headers['x-host'] = host;
    try {
        copyOptions.headers['User-Agent'] = await wx.getRendererUserAgent();
    }
    catch (error) { }
    const envId = (0, common_1.getConfig)('envID');
    const processUrl = (0, common_1.useTcbApi)() || !transferUrl
        ? url
        : `${url.replace(host, 'tcb-api.tencentcloudapi.com')}${url.indexOf('?') != -1 ? `&env=${envId}` : `?env=${envId}`}`;
    return {
        url: processUrl,
        body: copyOptions.body,
        method: copyOptions.method,
        headers: copyOptions.headers,
    };
}
const AUTH_BASE_CONFIG = {
    storage: new common_1.OauthClientStorgeBase({ localStorage: storage_1.wxMpStorage }),
    captchaOptions: {
        openURIWithCallback: (_url) => {
            let queryObj = {};
            let url = _url;
            const matched = _url.match(/^(data:.*?)(\?[^#\s]*)?$/);
            if (matched) {
                url = matched[1];
                const search = matched[2];
                if (search) {
                    queryObj = parseQueryString(search);
                }
            }
            const { token } = queryObj, restQueryObj = __rest(queryObj, ["token"]);
            if (/^data:/.test(url) && !token) {
                return Promise.reject({
                    error: 'invalid_argument',
                    error_description: `invlaie captcha data: ${_url}`,
                });
            }
            if (!token) {
                return Promise.reject({
                    error: 'unimplemented',
                    error_description: 'need to impl captcha data',
                });
            }
            return new Promise((resolve) => {
                console.log('wait for captcha...');
                eventBus_1.EVENT_BUS.emit('CAPTCHA_DATA_CHANGE', Object.assign(Object.assign({}, restQueryObj), { token, url }));
                eventBus_1.EVENT_BUS.once('RESOLVE_CAPTCHA_DATA', (res) => {
                    resolve(res);
                });
            });
        },
    },
};
function generateAuthBaseConfig(app) {
    return Object.assign({ baseRequest: (0, common_1.generateOauthClientRequest)((0, common_1.useTcbApi)()
            ? async (options) => {
                // Objects must be copied to prevent modification of data such as body.
                const { url, body, method, headers } = await processBaseRequestOptions(options, true);
                return new Promise((resolve, reject) => {
                    // @ts-ignore
                    wx.request({
                        url,
                        data: body,
                        method: method,
                        header: headers,
                        success(res) {
                            if (typeof res.data === 'object') {
                                resolve(res.data);
                            }
                            else {
                                reject(new Error(`resp data error for - ${res.data}`));
                            }
                        },
                        fail(res) {
                            reject(new Error(res.errMsg));
                        },
                    });
                });
            }
            : async (options) => {
                const { url, method, headers, body } = await processBaseRequestOptions(options);
                return app
                    .callFunction({
                    name: 'httpOverCallFunction',
                    data: {
                        url,
                        method,
                        headers: Object.assign({ origin: 'https://servicewechat.com' }, headers),
                        body,
                    },
                })
                    .then(({ result }) => result.body, (e) => {
                    throw new Error(e.errMsg);
                });
            }) }, AUTH_BASE_CONFIG);
}
exports.generateAuthBaseConfig = generateAuthBaseConfig;
function parseQueryString(queryString) {
    queryString = queryString.replace(/^\?/, '');
    const params = {};
    const pairs = queryString.split('&');
    pairs.forEach((item) => {
        let [key, value] = item.split('=');
        key = decodeURIComponent(key);
        value = decodeURIComponent(value);
        if (key) {
            if (params[key]) {
                if (Array.isArray(params[key])) {
                    params[key].push(value);
                }
                else {
                    params[key] = [params[key], value];
                }
            }
            else {
                params[key] = value;
            }
        }
    });
    return params;
}

import { callFunction } from './basic-api';
import { normalizeMessage } from './error-normalize';
import { getCommonCloudFnName, getConfig, deepClone } from '../common';
/**
 * 获取swr的信息
 * @param swrOptions
 * @param methodName
 * @returns
 */
const getSwrInfo = (swrOptions) => {
    if (swrOptions && Object.keys(swrOptions).length) {
        return Object.assign({ swrMode: true }, swrOptions);
    }
    return undefined;
};
/**
 * 调用数据源公共云函数(lcap-common-service)中提供的方法
 */
export async function callCommonService(params, app) {
    const paramsTemp = deepClone(params);
    const swr = deepClone(paramsTemp.swr || {});
    delete paramsTemp.swr;
    return callFunction({
        name: getCommonCloudFnName(),
        data: Object.assign(Object.assign({}, paramsTemp), { mode: 'c' }),
    }, {
        app,
        unwrapResult: true,
        parseBusinessInfo: true,
        swr,
    }).catch((e) => {
        throw normalizeMessage(e, {
            FUNCTION_NOT_FOUND: '微搭环境异常: 未找到数据源公共云函数',
            FUNCTIONS_EXECUTE_FAIL: '微搭环境异常: 数据源公共云函数调用失败',
        });
    });
}
/**
 * 调用流程
 */
export async function callWorkflow(params) {
    return callWedaApi(params);
}
/**
 * 检查权限
 */
export function checkAuth(params) {
    return callWedaApi({
        action: 'DescribeWedaAccessResourcesByType',
        data: params,
    });
}
/**
 * 调用微搭API
 */
export async function callWedaApi(params) {
    const paramsTemp = deepClone(params);
    if (params) {
        delete paramsTemp.swr;
    }
    return callCommonService({
        methodName: 'callWedaApi',
        params: paramsTemp,
        // 默认对 SWR_ACTION_DEFAULT 中的方法都开启swr
        swr: getSwrInfo(params === null || params === void 0 ? void 0 : params.swr),
    }).then((res) => res.Data);
}
/**
 * 根据数据源名称查询数据源信息(同步, 已废弃)
 * @deprecated use `getDataSourceProfileAsync` instead
 */
export function getDataSourceProfile(options) {
    const dataSourceProfiles = getConfig('dataSourceProfiles');
    if (!dataSourceProfiles || !dataSourceProfiles.length) {
        console.warn('[weda-cloud-sdk]datasource profile is empty');
        return;
    }
    const newOptions = typeof options === 'string' ? { val: options, key: 'name' } : options;
    const filter = typeof newOptions === 'function' ? newOptions : (item) => item && item[newOptions.key] === newOptions.val;
    return dataSourceProfiles.find(filter);
}
/**
 * 缓存查询结果
 *  key 为查询条件, value 为结果
 *  key 为 _ 的则存储结果的数组, 方便单独查询 dsName 时从中查询使用
 */
const CACHED_DS_PROFILE = {
    _: [],
};
/**
 * 根据数据源名称查询数据源信息(异步)
 */
export async function getDataSourceProfileAsync(dsName) {
    const isDsName = typeof dsName === 'string';
    const query = isDsName ? { Name: dsName } : dsName;
    const cachedKey = JSON.stringify(query);
    if (CACHED_DS_PROFILE[cachedKey])
        return simpleClone(CACHED_DS_PROFILE[cachedKey]);
    if (isDsName) {
        const dsProfile = CACHED_DS_PROFILE._.find((item) => item.name === dsName);
        if (dsProfile)
            return simpleClone(dsProfile);
    }
    const dataSourceProfiles = getConfig('dataSourceProfiles');
    if ((dataSourceProfiles === null || dataSourceProfiles === void 0 ? void 0 : dataSourceProfiles.length) && isDsName) {
        const dsProfile = dataSourceProfiles.find((item) => item.name === dsName);
        if (dsProfile)
            return simpleClone(dsProfile);
    }
    const { swrMode } = query;
    delete query.swrMode;
    const res = await callWedaApi({
        action: 'RuntimeDescribeDataSource',
        // @ts-ignore
        data: query,
        swr: { swrMode },
    });
    const result = standardizeDs(res);
    CACHED_DS_PROFILE[cachedKey] = result;
    CACHED_DS_PROFILE._.push(result);
    return simpleClone(result);
}
function simpleClone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
export function standardizeDs(ds) {
    const result = {};
    Object.keys(ds).reduce((acc, key) => {
        const camelCase = key.charAt(0).toLowerCase() + key.slice(1);
        acc[camelCase] = ds[key];
        return acc;
    }, result);
    const keysNeedParse = {
        schema: {},
        methods: [],
    };
    Object.keys(keysNeedParse).forEach((k) => {
        try {
            result[k] = JSON.parse(result[k]);
        }
        catch (error) {
            // @ts-ignore
            result[k] = keysNeedParse[k];
        }
    });
    return result;
}

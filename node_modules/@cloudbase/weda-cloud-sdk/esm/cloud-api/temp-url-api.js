/**
 * 获取云存储cos临时http链接
 */
import TTLCache from "@isaacs/ttlcache";
import { hasOwn, getConfig, PromiseAllSettled, isObject, isString } from '../common';
import { cloudConfig } from './config';
/** 批量一次转换的URL数量, 云开发侧超过 50 个即转换失败 */
const MAX_BATCH_LIMIT = 40;
/**
 * 转换链接请求合并截流等待的最长时间, 单位ms
 */
// const MAX_WAIT_TIME = 50;
/**
 * 已成功获取的文件ID及访问链接 Map
 */
const successCache = new TTLCache({
    max: 1000, ttl: 20 * 1000,
    // iframe 中timer有几率不执行
    checkAgeOnGet: true
});
/**
 * 正在处理中的文件ID数组
 */
let inProgress = [];
/**
 * 等待处理的文件ID数组
 */
let pending = [];
/**
 * 正在处理中的任务
 */
let tasks = [];
/**
 * 获取文件ID对应的访问链接地址
 *  每次调用即创建一个内部处理任务, 底层会将一段时间内的任务合并(即节流)再向后台发送转换请求
 * @param params 文件ID, 文件ID数组
 * @returns
 *  params 为字符串时, 任务成功则返回 字符串即链接地址, 失败则为 undefined
 *  params 为数组时, 返回结果为对象, 只包含获取成功的fileId结果, key 为 fileId, value 为其对应的链接地址
 */
export function getTempFileURL(params) {
    const fileIds = normalizeParams(params);
    if (!fileIds || !fileIds.length)
        return Promise.resolve();
    const result = try2getTaskResult(fileIds);
    if (result !== false)
        return Promise.resolve(result);
    return new Promise((resolve, reject) => {
        createTask(fileIds, resolve, reject);
    });
}
let nextTime = 0;
let tid = 0;
/**
 * 创建任务
 * @param fileIds 需要处理的文件ID
 * @param resolve promise 的 resolve
 * @param reject promise 的 reject
 */
function createTask(fileIds, resolve, reject) {
    tasks.push({ fileIds, resolve, reject });
    let files = (Array.isArray(fileIds) ? fileIds : [fileIds]).filter(v => isObject(v) || isString(v));
    // 去除掉正在等待的、正在处理的以及已经成功的
    if (pending.length) {
        files = files.filter(f => !pending.includes(f));
    }
    if (files.length && inProgress.length) {
        files = files.filter(f => !inProgress.includes(f));
    }
    if (files.length) {
        files = files.filter(f => !successCache.has(f));
    }
    if (!files.length)
        return;
    pending = pending.concat(files);
    clearTimeout(tid);
    const now = Date.now();
    nextTime = (!nextTime || now > nextTime) ? now + cloudConfig.tempURLMaxWaitGap : nextTime;
    // @ts-ignore
    tid = setTimeout(doGetTempURL, nextTime - now);
}
/**
 * 真正执行获取链接请求
 */
async function doGetTempURL() {
    const fileIds = pending.splice(0);
    inProgress = inProgress.concat(fileIds);
    try {
        const initTcb = getConfig('initTcb');
        const { app } = await initTcb();
        const allResponse = (await PromiseAllSettled(chunk(fileIds, MAX_BATCH_LIMIT)
            .map(fileList => app.getTempFileURL({ fileList })))).filter(v => v.status === 'fulfilled');
        inProgress = inProgress.filter(f => !fileIds.includes(f));
        const successList = allResponse.reduce((acc, v) => {
            const cur = v.value || {};
            if ((cur.code && cur.code !== 'SUCCESS')) {
                console.warn('[cloud.getTempFileURL]server response error', cur);
                return acc;
            }
            return acc.concat(cur.fileList);
        }, []);
        if (!successList.length) {
            checkAllTasks({}, fileIds);
            return;
        }
        ;
        const succeed = {};
        const failed = [];
        successList.forEach((item) => {
            if (isFileItemSuccess(item)) {
                succeed[item.fileID] = item.tempFileURL;
            }
            else {
                console.warn('[cloud.getTempFileURL]single item failed', item);
                failed.push(item.fileID);
            }
        });
        checkAllTasks(succeed, failed);
    }
    catch (error) {
        inProgress = inProgress.filter(f => !fileIds.includes(f));
        console.warn('[cloud.getTempFileURL] request failed', error);
        checkAllTasks({}, fileIds);
    }
}
/**
 * split array to chunks with specified size
 * @param arr array of fileIds
 * @param size chunk size
 * @returns 2 dimensional array
 */
function chunk(arr, size) {
    const result = [];
    for (let i = 0; i < arr.length; i += size) {
        result.push(arr.slice(i, i + size));
    }
    return result;
}
/**
 * 判断查询回来的单条文件信息是否成功
 *  微信和云开发返回的结果结构略有差异, 需要做兼容
 *    微信: https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/storage/Cloud.getTempFileURL.html
 *    云开发: https://docs.cloudbase.net/api-reference/webv2/storage#gettempfileurl
 */
function isFileItemSuccess(fileItem) {
    // 云开发, code 为 'SUCCESS' 表示成功
    if (hasOwn(fileItem, 'code'))
        return fileItem.code === 'SUCCESS';
    // 小程序, status 0 表示成功
    if (hasOwn(fileItem, 'status'))
        return !fileItem.status;
    return false;
}
/**
 * 检查所有任务
 * @param succeed 获取成功的结果对象
 * @param failed  获取失败的 fileId 数组
 */
function checkAllTasks(succeed, failed) {
    Object.keys(succeed !== null && succeed !== void 0 ? succeed : {}).forEach((k) => {
        successCache.set(k, succeed[k]);
    });
    tasks.forEach((task) => {
        const result = try2getTaskResult(task.fileIds, failed);
        if (result === false)
            return;
        task.resolve(result);
        // eslint-disable-next-line no-param-reassign
        task.isDone = true;
        return;
    });
    // 清除执行完成的任务
    tasks = tasks.filter(task => !task.isDone);
}
/**
 * 尝试获取任务结果
 * @param fileIds 要检查的文件ID列表
 * @param failed 请求失败的文件列表
 * @returns
 *  返回 false 表示还未全部取到, 即任务未结束
 *  fileIds 为字符串时, 任务成功则返回 字符串即链接地址, 失败则为 undefined
 *  fileIds 为数组时, 返回结果为对象, 只包含获取成功的fileId结果, key 为 fileId, value 为其对应的链接地址
 */
function try2getTaskResult(fileIds, failed = []) {
    try {
        if (Array.isArray(fileIds)) {
            const result = {};
            return fileIds.reduce((acc, cur) => {
                const val = successCache.get(cur);
                if (!val) {
                    if (failed.includes(cur))
                        return acc;
                    throw new Error('not found');
                }
                acc[cur] = val;
                return acc;
            }, result);
        }
        const val = successCache.get(fileIds);
        if (!val) {
            if (failed.includes(fileIds))
                return;
            throw new Error('not found');
        }
        return val;
    }
    catch (error) {
        return false;
    }
}
/**
 * 标准化参数
 * @param params 参数
 * @returns 字符串 或 字符串数组, 当参数不符合法时, 返回 undefined
 */
function normalizeParams(params) {
    // @ts-ignore
    const files = params && typeof params === 'object' && params.fileList ? params.fileList : params;
    if (typeof files === 'string')
        return files;
    if (Array.isArray(files))
        return files;
    return;
}

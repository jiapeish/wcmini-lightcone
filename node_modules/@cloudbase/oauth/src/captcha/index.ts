import { ApiUrls, ErrorType } from '../auth/consts';

import { App, RequestOptions, RequestFn, Storage, OpenURIWithCallback } from '../app';
import { _getComponent } from '../app/internal';
import { isMp, isInMpWebView } from '../utils/mp';

export interface CaptchaOptions {
  clientId?: string;
  request: RequestFn;
  storage: Storage;
  // 打开网页并通过URL回调获取 CaptchaToken，针对不通的平台，该函数可以自定义实现, 默认集成浏览器端认证
  openURIWithCallback?: OpenURIWithCallback;
}

export interface CaptchaInitOptions {
  request?: RequestFn;
}

export function getCaptcha(app: App, opts?: CaptchaInitOptions): Captcha {
  return _getComponent<Captcha>(app, 'captcha', (): Captcha => {
    const initOpts = {
      ...app.options.captchaOptions,
      clientId: app.options.clientId,
      request: app.options.request,
      storage: app.options.storage,
    };
    if (opts && opts.request) {
      initOpts.request = opts.request;
    }
    return new Captcha(initOpts);
  });
}

export interface CaptchaToken {
  captcha_token: string;
  expires_in: number;
  expires_at?: Date | null;
}

export interface CaptchaRequestOptions extends RequestOptions {
  withCaptcha?: boolean;
}

export interface GetCaptchaResponse {
  captcha_token?: string;
  expires_in?: number;
  url?: string;
}

export class Captcha {
  private config: CaptchaOptions;
  private tokenSectionName: string;

  /**
   * constructor
   * @param {CaptchaOptions} opts
   */
  constructor(opts: CaptchaOptions) {
    this.config = opts;
    this.tokenSectionName = `captcha_${opts.clientId || ''}`;
  }

  /**
   * request http like simple fetch api, exp:request('/v1/user/me', {withCredentials:true})
   * @param {string} url
   * @param {AuthClientRequestOptions} options
   */
  public async request<T>(url: string, options?: CaptchaRequestOptions): Promise<T> {
    if (!options) {
      options = {};
    }
    if (!options.method) {
      options.method = 'GET';
    }
    const state = `${options.method}:${url}`;
    let reqURL = url;
    if (options.withCaptcha) {
      reqURL = await this.appendCaptchaTokenToURL(url, state, false);
    }

    let resp: T;
    try {
      resp = await this.config.request<T>(reqURL, options);
    } catch (err: any) {
      if (err.error === ErrorType.CAPTCHA_REQUIRED || err.error === ErrorType.CAPTCHA_INVALID) {
        url = await this.appendCaptchaTokenToURL(url, state, err.error === ErrorType.CAPTCHA_INVALID);
        return this.config.request<T>(url, options);
      }
      return Promise.reject(err);
    }
    return resp;
  }

  /**
   * getCaptchaToken 获取captchaToken
   */
  private async getCaptchaToken(forceNewToken: boolean, state: string): Promise<string> {
    if (!forceNewToken) {
      // 如果本地存在，则直接返回
      const captchaToken = await this.findCaptchaToken();
      if (captchaToken) {
        return captchaToken;
      }
    }
    let captchaTokenResp: {
      url?: string;
      captcha_token?: string;
      expires_in?: number;
    };
    if (isMp() || isInMpWebView()) {
      /**
       * https://iwiki.woa.com/p/4010699417
       */
      const captchaDataResp = await this.config.request<{
        data: string;
        type: 'image';
        token: string;
        expires_in: number;
      }>(ApiUrls.CAPTCHA_DATA_URL, {
        method: 'POST',
        body: {
          state,
          redirect_uri: '',
        },
        withBasicAuth: true,
        withCredentials: false,
      });
      captchaTokenResp = {
        url: `${captchaDataResp.data}?state=${encodeURIComponent(state)}&token=${captchaDataResp.token}`,
      };
    } else {
      const redirect_uri = `${window.location.origin + window.location.pathname}?__captcha=on`;
      captchaTokenResp = await this.config.request<GetCaptchaResponse>(ApiUrls.GET_CAPTCHA_URL, {
        method: 'POST',
        body: {
          client_id: this.config.clientId,
          redirect_uri,
          state,
        },
        withBasicAuth: true,
      });
    }

    const captchaToken = captchaTokenResp.captcha_token
      ? {
          captcha_token: captchaTokenResp.captcha_token,
          expires_in: captchaTokenResp.expires_in,
        }
      : await this.config.openURIWithCallback(captchaTokenResp.url, {
          width: '355px',
          height: '355px',
        });

    await this.saveCaptchaToken({
      captcha_token: captchaToken.captcha_token,
      expires_in: Number(captchaToken.expires_in),
    });
    return captchaToken.captcha_token;
  }

  private async appendCaptchaTokenToURL(url: string, state: string, forceNewToken: boolean): Promise<string> {
    const captchaToken = await this.getCaptchaToken(forceNewToken, state);
    if (url.indexOf('?') > 0) {
      url += `&captcha_token=${captchaToken}`;
    } else {
      url += `?captcha_token=${captchaToken}`;
    }
    return url;
  }

  private async saveCaptchaToken(token: CaptchaToken) {
    token.expires_at = new Date(Date.now() + (token.expires_in - 10) * 1000);
    const tokenStr: string = JSON.stringify(token);
    await this.config.storage.setItem(this.tokenSectionName, tokenStr);
  }

  private async findCaptchaToken(): Promise<string> {
    const tokenStr: string = await this.config.storage.getItem(this.tokenSectionName);
    if (tokenStr !== undefined && tokenStr !== null) {
      try {
        const captchaToken = JSON.parse(tokenStr);
        if (captchaToken && captchaToken.expires_at) {
          captchaToken.expires_at = new Date(captchaToken.expires_at);
        }
        const isExpired = captchaToken.expires_at < new Date();
        if (isExpired) {
          return null;
        }
        return captchaToken.captcha_token;
      } catch (error) {
        await this.config.storage.removeItem(this.tokenSectionName);
        return null;
      }
    }
    return null;
  }
}

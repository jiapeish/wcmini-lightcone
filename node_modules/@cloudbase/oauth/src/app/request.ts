export interface RequestOptions {
  body?: any | null;
  headers?: any | null;
  method?: string;

  [key: string]: any;
}

export enum ErrorType {
  UNREACHABLE = 'unreachable',
}

export type RequestFn = <T>(url: string, options?: RequestOptions) => Promise<T>;

/** An Error For all concern **/
export interface ResponseError {
  error: string;
  error_description?: string;
  error_uri?: string;
  details?: any;
  request_id?: string;
}

export const defaultRequest: RequestFn = async <T>(url: string, options?: RequestOptions): Promise<T> => {
  let result: T;
  let responseError: ResponseError;
  // Objects must be copied to prevent modification of data such as body.
  const copyOptions = Object.assign({}, options);
  if (!copyOptions.method) {
    copyOptions.method = 'GET';
  }
  if (copyOptions.body && typeof copyOptions.body !== 'string') {
    copyOptions.body = JSON.stringify(copyOptions.body, (key, value) => {
      if (value) {
        if (value instanceof Map) {
          return Object.fromEntries(value.entries());
        } else if (value !== '') {
          return value;
        }
      }
    });
  }
  const requestId = copyOptions.headers['x-request-id'] as string;
  try {
    copyOptions.credentials = 'include';
    const responseResult: Response = await fetch(url, copyOptions);
    const jsonResponse = await responseResult.json();
    if (jsonResponse.error || responseResult.status >= 400) {
      responseError = jsonResponse as ResponseError;
      responseError.error_uri = new URL(url).pathname;
      responseError.request_id = requestId;
    } else {
      result = jsonResponse as T;
    }
  } catch (error: any) {
    responseError = {
      error: ErrorType.UNREACHABLE,
      error_description: error.message,
      error_uri: new URL(url).pathname,
      request_id: requestId,
    };
  }
  if (responseError) {
    throw responseError;
  } else {
    return result as T;
  }
};

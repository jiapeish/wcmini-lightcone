import { GetVerificationRequest, GetVerificationResponse, UserProfile, UserInfo, SignInRequest, SignUpRequest, VerifyRequest, VerifyResponse, GenProviderRedirectUriRequest, GenProviderRedirectUriResponse, GrantProviderTokenRequest, GrantProviderTokenResponse, PatchProviderTokenRequest, PatchProviderTokenResponse, SignInWithProviderRequest, BindWithProviderRequest, TransByProviderRequest, GrantTokenRequest, UserProfileProvider, UnbindProviderRequest, CheckPasswordrRequest, BindPhoneRequest, BindEmailRequest, SetPasswordRequest, ChangeBindedProviderRequest, ChangeBindedProviderResponse, UpdatePasswordRequest, SudoResponse, SudoRequest, GetCustomSignTicketFn, QueryUserProfileRequest, QueryUserProfileResponse, ResetPasswordRequest, DeviceAuthorizeRequest, DeviceAuthorizeResponse, CheckUsernameRequest, CheckIfUserExistRequest, CheckIfUserExistResponse, WithSudoRequest, PublicKey, EncryptParams, ProviderSubType, GetMiniProgramQrCodeRequest, GetMiniProgramQrCodeStatusRequest, GetMiniProgramQrCodeResponse, GetMiniProgramQrCodeStatusResponse, ModifyUserBasicInfoRequest } from './models';
import { SimpleStorage, RequestFunction } from '../oauth2client/interface';
import { OAuth2Client } from '../oauth2client/oauth2client';
import { Credentials } from '../oauth2client/models';
import { CaptchaOptions } from '../captcha/captcha';
export interface AuthOptions {
    apiOrigin: string;
    clientId: string;
    credentialsClient?: OAuth2Client;
    request?: RequestFunction;
    baseRequest?: RequestFunction;
    storage?: SimpleStorage;
    anonymousSignInFunc?: (Credentials: any) => Promise<Credentials | void>;
    captchaOptions?: Partial<CaptchaOptions>;
}
export declare class Auth {
    private static parseParamsToSearch;
    private config;
    private getCustomSignTicketFn?;
    constructor(opts: AuthOptions);
    getParamsByVersion(params: any, key: string): {
        params: any;
        url: any;
    };
    signIn(params: SignInRequest): Promise<Credentials>;
    signInAnonymously(data?: {
        provider_token?: string;
    }): Promise<Credentials>;
    signUp(params: SignUpRequest): Promise<Credentials>;
    signOut(): Promise<any>;
    getVerification(params: GetVerificationRequest): Promise<GetVerificationResponse>;
    verify(params: VerifyRequest): Promise<VerifyResponse>;
    genProviderRedirectUri(params: GenProviderRedirectUriRequest): Promise<GenProviderRedirectUriResponse>;
    grantProviderToken(params: GrantProviderTokenRequest): Promise<GrantProviderTokenResponse>;
    patchProviderToken(params: PatchProviderTokenRequest): Promise<PatchProviderTokenResponse>;
    signInWithProvider(params: SignInWithProviderRequest): Promise<Credentials>;
    signInWithWechat(params?: any): Promise<Credentials>;
    bindWithProvider(params: BindWithProviderRequest): Promise<void>;
    getUserProfile(params: {
        version?: string;
    }): Promise<UserProfile>;
    getUserInfo(params?: {
        version?: string;
        query?: string;
    }): Promise<UserInfo>;
    getWedaUserInfo(): Promise<any>;
    deleteMe(params: WithSudoRequest): Promise<UserProfile>;
    hasLoginState(): Promise<boolean>;
    hasLoginStateSync(): Credentials | null;
    getLoginState(): Promise<Credentials | null>;
    transByProvider(params: TransByProviderRequest): Promise<Credentials>;
    grantToken(params: GrantTokenRequest): Promise<Credentials>;
    getProviders(): Promise<UserProfileProvider>;
    unbindProvider(params: UnbindProviderRequest): Promise<void>;
    checkPassword(params: CheckPasswordrRequest): Promise<void>;
    bindPhone(params: BindPhoneRequest): Promise<void>;
    bindEmail(params: BindEmailRequest): Promise<void>;
    setPassword(params: SetPasswordRequest): Promise<void>;
    updatePasswordByOld(params: UpdatePasswordRequest): Promise<void>;
    sudo(params: SudoRequest): Promise<SudoResponse>;
    getCurUserVerification(params: GetVerificationRequest): Promise<GetVerificationResponse>;
    changeBindedProvider(params: ChangeBindedProviderRequest): Promise<ChangeBindedProviderResponse>;
    setUserProfile(params: UserProfile): Promise<UserProfile>;
    updateUserBasicInfo(params: ModifyUserBasicInfoRequest): Promise<void>;
    queryUserProfile(params: QueryUserProfileRequest): Promise<QueryUserProfileResponse>;
    setCustomSignFunc(getTickFn: GetCustomSignTicketFn): void;
    signInWithCustomTicket(params?: {
        version?: string;
    }): Promise<Credentials>;
    resetPassword(params: ResetPasswordRequest): Promise<void>;
    deviceAuthorize(params: DeviceAuthorizeRequest): Promise<DeviceAuthorizeResponse>;
    checkUsername(params: CheckUsernameRequest): Promise<void>;
    checkIfUserExist(params: CheckIfUserExistRequest): Promise<CheckIfUserExistResponse>;
    loginScope(): Promise<string>;
    loginGroups(): Promise<string[]>;
    refreshTokenForce(params: {
        version?: string;
    }): Promise<Credentials>;
    getCredentials(): Promise<Credentials>;
    getPublicKey(): Promise<PublicKey>;
    getEncryptParams(params: Record<any, any>): Promise<EncryptParams>;
    getProviderSubType(): Promise<ProviderSubType>;
    verifyCaptchaData({ token, key }: {
        token: string;
        key: string;
    }): Promise<{
        captcha_token: string;
        expires_in: number;
    }>;
    createCaptchaData({ state, redirect_uri }: {
        state: any;
        redirect_uri?: any;
    }): Promise<{
        captcha_token: string;
        expires_in: number;
    }>;
    getMiniProgramCode(params: GetMiniProgramQrCodeRequest): Promise<GetMiniProgramQrCodeResponse>;
    checkMiniProgramCode(params: GetMiniProgramQrCodeStatusRequest): Promise<GetMiniProgramQrCodeStatusResponse>;
}

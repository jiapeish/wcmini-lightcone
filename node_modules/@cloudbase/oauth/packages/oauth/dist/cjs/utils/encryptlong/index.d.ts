export default JSEncrypt;
declare function JSEncrypt(options?: any): void;
declare class JSEncrypt {
    constructor(options?: any);
    default_key_size: number;
    default_public_exponent: any;
    log: any;
    key: JSEncryptRSAKey;
    public setKey(key: any | string): void;
    public setPrivateKey(privkey: any): void;
    public setPublicKey(pubkey: any): void;
    public decrypt(str: string): string;
    public encrypt(str: string): string;
    public encryptLong(str: string): string;
    public decryptLong(str: string): string;
    public sign(str: string, digestMethod: Function, digestName: string): string;
    public verify(str: string, signature: string, digestMethod: Function): boolean;
    public getKey(cb?: callback): JSEncryptRSAKey;
    public getPrivateKey(): string;
    public getPrivateKeyB64(): string;
    public getPublicKey(): string;
    public getPublicKeyB64(): string;
}
declare namespace JSEncrypt {
    const version: string;
}
declare class JSEncryptRSAKey extends RSAKey {
    static wordwrap(str: string, width?: number): string;
    constructor(key?: string);
    parseKey(pem: string): boolean;
    getPrivateBaseKey(): string;
    public getPrivateBaseKeyB64(): string;
    getPublicBaseKey(): string;
    public getPublicBaseKeyB64(): string;
    public getPrivateKey(): string;
    public getPublicKey(): string;
    hasPublicKeyProperty(obj?: any): boolean;
    hasPrivateKeyProperty(obj?: any): boolean;
    parsePropertiesFrom(obj: any): void;
}
declare class RSAKey {
    n: any;
    e: number;
    d: BigInteger;
    p: any;
    q: any;
    dmp1: BigInteger;
    dmq1: BigInteger;
    coeff: any;
    doPublic(x: any): any;
    doPrivate(x: any): any;
    setPublic(N: any, E: any): void;
    encrypt(text: any): any;
    encryptLong(text: any): string;
    decryptLong(text: any): string;
    setPrivate(N: any, E: any, D: any): void;
    setPrivateEx(N: any, E: any, D: any, P: any, Q: any, DP: any, DQ: any, C: any): void;
    generate(B: any, E: any): void;
    decrypt(ctext: any): string;
    generateAsync(B: any, E: any, callback: any): void;
    sign(text: any, digestMethod: any, digestName: any): any;
    verify(text: any, signature: any, digestMethod: any): boolean;
}
declare class BigInteger {
    constructor(a: any, b: any, c: any);
    toString(b: any): any;
    negate(): BigInteger;
    abs(): BigInteger;
    compareTo(a: any): number;
    bitLength(): number;
    mod(a: any): BigInteger;
    modPowInt(e: any, m: any): any;
    clone(): BigInteger;
    intValue(): any;
    byteValue(): number;
    shortValue(): number;
    signum(): 0 | 1 | -1;
    toByteArray(): number[];
    equals(a: any): boolean;
    min(a: any): any;
    max(a: any): any;
    and(a: any): BigInteger;
    or(a: any): BigInteger;
    xor(a: any): BigInteger;
    andNot(a: any): BigInteger;
    not(): BigInteger;
    shiftLeft(n: any): BigInteger;
    shiftRight(n: any): BigInteger;
    getLowestSetBit(): number;
    bitCount(): number;
    testBit(n: any): boolean;
    setBit(n: any): BigInteger;
    clearBit(n: any): BigInteger;
    flipBit(n: any): BigInteger;
    add(a: any): BigInteger;
    subtract(a: any): BigInteger;
    multiply(a: any): BigInteger;
    divide(a: any): BigInteger;
    remainder(a: any): BigInteger;
    divideAndRemainder(a: any): BigInteger[];
    modPow(e: any, m: any): any;
    modInverse(m: any): BigInteger;
    pow(e: any): any;
    gcd(a: any): any;
    isProbablePrime(t: any): boolean;
    copyTo(r: any): void;
    fromInt(x: any): void;
    t: number;
    s: number;
    0: any;
    fromString(s: any, b: any): void;
    clamp(): void;
    dlShiftTo(n: any, r: any): void;
    drShiftTo(n: any, r: any): void;
    lShiftTo(n: any, r: any): void;
    rShiftTo(n: any, r: any): void;
    subTo(a: any, r: any): void;
    multiplyTo(a: any, r: any): void;
    squareTo(r: any): void;
    divRemTo(m: any, q: any, r: any): void;
    invDigit(): number;
    isEven(): boolean;
    exp(e: any, z: any): any;
    chunkSize(r: any): number;
    toRadix(b: any): string;
    fromRadix(s: any, b: any): void;
    fromNumber(a: any, b: any, c: any): void;
    bitwiseTo(a: any, op: any, r: any): void;
    changeBit(n: any, op: any): BigInteger;
    addTo(a: any, r: any): void;
    dMultiply(n: any): void;
    dAddOffset(n: any, w: any): void;
    multiplyLowerTo(a: any, n: any, r: any): void;
    multiplyUpperTo(a: any, n: any, r: any): void;
    modInt(n: any): number;
    millerRabin(t: any): boolean;
    square(): BigInteger;
    gcda(a: any, callback: any): void;
    fromNumberAsync(a: any, b: any, c: any, callback: any): void;
    am: typeof am2 | typeof am1 | typeof am3;
    DB: number;
    DM: number;
    DV: number;
    FV: number;
    F1: number;
    F2: number;
}
declare namespace BigInteger {
    const ZERO: BigInteger;
    const ONE: BigInteger;
}
declare function am2(i: any, x: any, w: any, j: any, c: any, n: any): any;
declare function am1(i: any, x: any, w: any, j: any, c: any, n: any): any;
declare function am3(i: any, x: any, w: any, j: any, c: any, n: any): any;

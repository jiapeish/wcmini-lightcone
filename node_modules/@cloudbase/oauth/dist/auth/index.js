'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.Auth = exports.getAuth = exports.DeviceAuthorizeState = exports.VerificationUsages = exports.ErrorType = void 0;
const consts_1 = require("./consts");
const oauthclient_1 = require("../oauthclient");
const captcha_1 = require("../captcha");
const internal_1 = require("../app/internal");
var consts_2 = require("./consts");
Object.defineProperty(exports, "ErrorType", { enumerable: true, get: function () { return consts_2.ErrorType; } });
Object.defineProperty(exports, "VerificationUsages", { enumerable: true, get: function () { return consts_2.VerificationUsages; } });
Object.defineProperty(exports, "DeviceAuthorizeState", { enumerable: true, get: function () { return consts_2.DeviceAuthorizeState; } });
/**
 * Returns the existing `Auth` instance that is associated with the app
 */
function getAuth(app, initOptions) {
    return (0, internal_1._getComponent)(app, 'auth', () => {
        const credentialsClient = (0, oauthclient_1.getOAuthClient)(app, initOptions);
        const baseRequest = credentialsClient.request.bind(credentialsClient);
        const captcha = (0, captcha_1.getCaptcha)(app, { request: baseRequest });
        return new Auth({
            credentialsClient: credentialsClient,
            captcha: captcha,
        });
    });
}
exports.getAuth = getAuth;
/**
 * Auth
 */
class Auth {
    /**
     * constructor
     * @param {AuthOptions} opts
     */
    constructor(opts) {
        this.request = opts.captcha.request.bind(opts.captcha);
        this.credentialsClient = opts.credentialsClient;
    }
    /**
     * Sign in.
     * @param {SignInRequest} params A SignInRequest Object.
     * @return {Promise<Credentials>} A Promise<Credentials> object.
     */
    async signIn(params) {
        const credentials = await this.request(consts_1.ApiUrls.AUTH_SIGN_IN_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
        await this.credentialsClient.setCredentials(credentials);
        return Promise.resolve(credentials);
    }
    /**
     * Sign in Anonymously
     * @return {Promise<Credentials>} A Promise<Credentials> object.
     */
    async signInAnonymously() {
        const credentials = await this.request(consts_1.ApiUrls.AUTH_SIGN_IN_ANONYMOUSLY_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: {},
        });
        await this.credentialsClient.setCredentials(credentials);
        return Promise.resolve(credentials);
    }
    /**
     * sign in with wechat idendify
     * 需要结合 http overcallFunction 使用
     */
    async signInWithWechat(params = {}) {
        const credentials = await this.request(consts_1.ApiUrls.AUTH_SIGN_IN_WITH_WECHAT_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
        await this.credentialsClient.setCredentials(credentials);
        return Promise.resolve(credentials);
    }
    /**
     * Sign up.
     * @param {SignUpRequest} params A SignUpRequest Object.
     * @return {Promise<Credentials>} A Promise<Credentials> object.
     */
    async signUp(params) {
        const data = await this.request(consts_1.ApiUrls.AUTH_SIGN_UP_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
        await this.credentialsClient.setCredentials(data);
        return Promise.resolve(data);
    }
    /**
     * Sign out.
     * @param {SignoutRequest} params A SignoutRequest Object.
     * @return {SignoutReponse} A Promise<SignoutReponse> object.
     */
    async signOut(params) {
        var resp = {};
        if (!params) {
            params = {};
        }
        try {
            resp = await this.request(consts_1.ApiUrls.AUTH_SIGNOUT_URL, {
                method: 'POST',
                withCredentials: true,
                body: params,
            });
        }
        catch (err) {
            if (err.error !== oauthclient_1.ErrorType.UNAUTHENTICATED) {
                console.log('sign_out_error', err);
            }
        }
        await this.credentialsClient.setCredentials();
        return resp;
    }
    /**
     * Revoke All Devices
     * @return {Object} A Promise<void> object.
     */
    async revokeAllDevices() {
        await this.request(consts_1.ApiUrls.AUTH_REVOKE_ALL_URL, {
            method: 'DELETE',
            withCredentials: true,
        });
    }
    /**
     * Revoke Device
     * @return {Object} A Promise<void> object.
     */
    async revokeDevice(params) {
        await this.request(consts_1.ApiUrls.AUTHORIZED_DEVICES_DELETE_URL + params.device_id, {
            method: 'DELETE',
            withCredentials: true,
        });
    }
    /**
     * Send the VerificationCode.
     * @param {SendVerificationCodeRequest} params A GetVerificationRequest Object.
     * @return {Promise<SendVerificationCodeResponse>} A Promise<GetVerificationResponse> object.
     */
    async sendVerificationCode(params) {
        let withBasicAuth = false;
        let withCredentials = false;
        // 发送短信时，如果时给当前用户发，则需要带上鉴权信息
        if (params.target == 'CUR_USER') {
            withCredentials = true;
        }
        else {
            const hasLogin = await this.hasLoginState();
            if (hasLogin) {
                withCredentials = true;
            }
            else {
                withBasicAuth = true;
            }
        }
        return this.request(consts_1.ApiUrls.VERIFICATION_URL, {
            method: 'POST',
            withBasicAuth: withBasicAuth,
            withCredentials: withCredentials,
            body: params,
            // withCaptcha: true,
        });
    }
    async getVerification(params) {
        return this.sendVerificationCode(params);
    }
    /**
     *  Verify the code
     * @param {VerifyRequest} params A VerifyRequest Object.
     * @return {Promise<VerifyResponse>} A Promise<VerifyResponse> object.
     */
    async verify(params) {
        return this.request(consts_1.ApiUrls.VERIFY_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
    }
    /**
     * Reset Password
     * @param params A ResetPasswordRequest Object
     */
    async resetPassword(params) {
        return this.request(consts_1.ApiUrls.RESET_PASSWORD_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
    }
    /**
     * Gen provider redirect uri.
     * @param {GenProviderRedirectUriRequest} params A GenProviderRedirectUriRequest object.
     * @return {Promise<GenProviderRedirectUriResponse>} A Promise<GenProviderRedirectUriResponse> object.
     */
    async genProviderRedirectUri(params) {
        const otherParams = params.other_params;
        delete params.other_params;
        let url = `${consts_1.ApiUrls.PROVIDER_URI_URL}?${Auth.parseParamsToSearch(params)}`;
        if (otherParams) {
            otherParams.forEach((value, key) => {
                url += `&other_params[${key}]=${encodeURIComponent(value)}`;
            });
        }
        return this.request(url, {
            method: 'GET',
            withBasicAuth: true,
        });
    }
    /**
     * Grant provider token.
     * @param {GrantProviderTokenRequest} params A GrantProviderTokenRequest object.
     * @return {Promise<GrantProviderTokenResponse>} A Promise<GrantProviderTokenResponse> object.
     */
    async grantProviderToken(params) {
        return this.request(consts_1.ApiUrls.PROVIDER_TOKEN_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
    }
    /**
     * Grant provider token.
     * @param {PatchProviderTokenRequest} params A PatchProviderTokenRequest object.
     * @return {Promise<PatchProviderTokenResponse>} A Promise<PatchProviderTokenResponse> object.
     */
    async patchProviderToken(params) {
        return this.request(consts_1.ApiUrls.PROVIDER_TOKEN_URL, {
            method: 'PATCH',
            withBasicAuth: true,
            body: params,
        });
    }
    /**
     * Signin with provider request.
     * @param {SignInWithProviderRequest} params A SignInWithProviderRequest object.
     * @return {Promise<Credentials>} A Promise<Credentials> object.
     */
    async signInWithProvider(params) {
        const credentials = await this.request(consts_1.ApiUrls.AUTH_SIGN_IN_WITH_PROVIDER_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
        await this.credentialsClient.setCredentials(credentials);
        return Promise.resolve(credentials);
    }
    /**
     * Bind with provider
     * @param {BindWithProviderRequest} params A BindWithProviderRequest object.
     * @return {Promise<void>} A Promise<void> object.
     */
    async bindWithProvider(params) {
        return this.request(consts_1.ApiUrls.PROVIDER_BIND_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
            withCredentials: true,
        });
    }
    /**
     * Get the user profile.
     * @return {Promise<UserProfile>} A Promise<UserProfile> object.
     */
    async getUserProfile() {
        return this.request(consts_1.ApiUrls.USER_ME_URL, {
            method: 'GET',
            withCredentials: true,
        });
    }
    /**
     * Get the user profile.
     * @return {Promise<UserProfile>} A Promise<UserProfile> object.
     */
    async updateUserProfile(params) {
        return this.request(consts_1.ApiUrls.USER_ME_URL, {
            method: 'PATCH',
            withCredentials: true,
            body: params,
        });
    }
    /**
     * Update user basic info
     * @return {Promise<void>}
     */
    async updateUserBasicInfo(params) {
        return this.request(consts_1.ApiUrls.USER_BASIC_EDIT_URL, {
            method: 'POST',
            withCredentials: true,
            body: params,
        });
    }
    /**
     * hasLoginState check if has login state
     * @return {Promise<boolean>} A Promise<boolean> object.
     */
    async hasLoginState() {
        try {
            await this.credentialsClient.getAccessToken();
            return true;
        }
        catch (err) {
            if (err.error === oauthclient_1.ErrorType.UNAUTHENTICATED) {
                return false;
            }
            return Promise.reject(err);
        }
    }
    /**
     * loginScope return scope of current token
     * @return {Promise<string>} A Promise<string> object.
     */
    async loginScope() {
        return this.credentialsClient.getScope();
    }
    /**
     * Trans by provider.
     * @param {TransByProviderRequest} params A TransByProviderRequest object.
     * @return {Promise<Credentials>} A Promise<Credentials> object.
     */
    async transByProvider(params) {
        return this.request(consts_1.ApiUrls.USER_TRANS_BY_PROVIDER_URL, {
            method: 'PATCH',
            body: params,
            withCredentials: true,
        });
    }
    /**
     * Grant token.
     * @param {GrantTokenRequest} params A GrantTokenRequest object.
     * @return {Promise<Credentials>} A Promise<Credentials> object.
     */
    async grantToken(params) {
        const credentials = await this.request(consts_1.ApiUrls.AUTH_TOKEN_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
        await this.credentialsClient.setCredentials(credentials);
        return Promise.resolve(credentials);
    }
    /**
     * Get the provide list.
     * @return {Promise<ProvidersResponse>} A Promise<UserProfileProviderList> object.
     */
    async getProviders() {
        return this.request(consts_1.ApiUrls.PROVIDER_LIST_URL, {
            method: 'GET',
            withCredentials: true,
        });
    }
    /**
     * check if username is exist
     * @param params CheckIfUserExistRequest
     */
    async checkIfUserExist(params) {
        const url = `${consts_1.ApiUrls.USER_ME_URL}?${Auth.parseParamsToSearch(params)}`;
        return this.request(url, {
            method: 'GET',
        });
    }
    /**
     * unbind provider.
     * @param {UnbindProviderRequest} params
     * @return {Promise<void>}
     */
    async unbindProvider(params) {
        return this.request(`${consts_1.ApiUrls.PROVIDER_UNBIND_URL}/${params.provider_id}`, {
            method: 'DELETE',
            withCredentials: true,
        });
    }
    /**
     * check Password.
     * @param {CheckPasswordRequest} params
     * @return {Promise<void>}
     */
    async checkPassword(params) {
        return this.request(`${consts_1.ApiUrls.SUDO_URL}`, {
            method: 'POST',
            withCredentials: true,
            body: params,
        });
    }
    /**
     * Edit Contact 修改 手机号 或 邮箱
     * @param {EditContactRequest} params
     * @return {Promise<void>}
     */
    async editContact(params) {
        return this.request(`${consts_1.ApiUrls.EDIT_CONTACT_URL}`, {
            method: 'PATCH',
            withCredentials: true,
            body: params,
        });
    }
    /**
     * Set Password.
     * @param {SetPasswordRequest} params
     * @return {Promise<void>}
     */
    async setPassword(params) {
        return this.request(`${consts_1.ApiUrls.AUTH_SET_PASSWORD_URL}`, {
            method: 'PATCH',
            withCredentials: true,
            body: params,
        });
    }
    /**
     * updatePasswordByOld 使用旧密码修改密码，如果已经绑定手机号，请先：sudo，再修改密码
     * @param {UpdatePasswordRequest} params
     * @return {Promise<void>}
     */
    async updatePasswordByOld(params) {
        const sudoToken = await this.sudo({ password: params.old_password });
        return this.setPassword({
            sudo_token: sudoToken.sudo_token,
            new_password: params.new_password,
        });
    }
    /**
     * sudo
     * @param {sudo} params
     * @return {Promise<SudoResponse>}
     */
    async sudo(params) {
        return this.request(`${consts_1.ApiUrls.SUDO_URL}`, {
            method: 'POST',
            withCredentials: true,
            body: params,
        });
    }
    /**
     * Get the current user verification.
     * @param {SendVerificationCodeRequest} params A SendVerificationCodeToCurrentUser Object.
     * @return {Promise<SendVerificationCodeResponse>} A Promise<SendVerificationCodeResponse> object.
     */
    async SendVerificationCodeToCurrentUser(params) {
        params.target = 'CUR_USER';
        return this.request(consts_1.ApiUrls.VERIFICATION_URL, {
            method: 'POST',
            body: params,
            withCredentials: true,
            withCaptcha: true,
        });
    }
    /**
     * change Bound provider.
     * @param {ChangeBoundProviderRequest} params A GetVerificationRequest Object.
     * @return {Promise<ChangeBoundProviderResponse>} A Promise<GetVerificationResponse> object.
     */
    async changeBoundProvider(params) {
        return this.request(`${consts_1.ApiUrls.PROVIDER_LIST_URL}/${params.provider_id}/trans`, {
            method: 'POST',
            body: {
                provider_trans_token: params.trans_token,
            },
            withCredentials: true,
        });
    }
    /**
     * set the user profile.
     * @param {UserProfile} params A UserProfile Object.
     * @return {Promise<UserProfile>} A Promise<UserProfile> object.
     */
    async setUserProfile(params) {
        return this.request(consts_1.ApiUrls.USER_PROFILE_URL, {
            method: 'PATCH',
            body: params,
            withCredentials: true,
        });
    }
    /**
     * Delete me
     * @param params
     */
    async deleteMe(params) {
        const url = `${consts_1.ApiUrls.USER_ME_URL}?${Auth.parseParamsToSearch(params)}`;
        return this.request(url, {
            method: 'DELETE',
            withCredentials: true,
        });
    }
    /**
     * setCustomSignFunc set the get ticket function
     * @param getTickFn
     */
    setCustomSignFunc(getTickFn) {
        this._getCustomSignTicketFn = getTickFn;
    }
    /**
     * SignInWithCustomTicket custom signIn
     * @constructor
     */
    async SignInWithCustomTicket() {
        const customSignTicketFn = this._getCustomSignTicketFn;
        if (!customSignTicketFn) {
            return Promise.reject({
                error: 'failed_precondition',
                error_description: 'please use setCustomSignFunc to set custom sign function',
            });
        }
        const customTicket = await customSignTicketFn();
        return this.signInWithProvider({
            provider_id: 'custom',
            provider_token: customTicket,
        });
    }
    /**
     * queryUserProfile query user profile
     * @param params queryUserProfile query user profile
     */
    async queryUserProfile(params) {
        const url = `${consts_1.ApiUrls.USER_QUERY_URL}?${Auth.parseParamsToSearch(params)}`;
        return this.request(url, {
            method: 'GET',
            withCredentials: true,
        });
    }
    /**
     * Authorize oauth Authorize
     * @param params
     * @constructor
     */
    async authorize(params) {
        return this.request(consts_1.ApiUrls.AUTHORIZE_URL, {
            method: 'POST',
            withCredentials: true,
            body: params,
        });
    }
    /**
     * authorize device
     * @param params
     */
    async authorizeDevice(params) {
        return this.request(consts_1.ApiUrls.AUTHORIZE_DEVICE_URL, {
            method: 'POST',
            withCredentials: true,
            body: params,
        });
    }
    async deviceAuthorize(params) {
        return this.request(consts_1.ApiUrls.AUTHORIZE_DEVICE_CODE_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
    }
    /**
     * OAuth get authorize info
     * @param params
     * @constructor
     */
    async authorizeInfo(params) {
        const url = `${consts_1.ApiUrls.AUTHORIZE_INFO_URL}?${Auth.parseParamsToSearch(params)}`;
        let withBasicAuth = true;
        let withCredentials = false;
        const hasLogin = await this.hasLoginState();
        if (hasLogin) {
            withCredentials = true;
            withBasicAuth = false;
        }
        return this.request(url, {
            method: 'GET',
            withBasicAuth: withBasicAuth,
            withCredentials: withCredentials,
        });
    }
    /**
     * get provider sub type
     * @returns
     */
    async getProviderSubType() {
        return this.request(consts_1.ApiUrls.GET_PROVIDER_TYPE, {
            method: 'POST',
            body: {
                provider_id: 'weda',
            },
        });
    }
    async createCaptchaData(params) {
        return this.request(consts_1.ApiUrls.CAPTCHA_DATA_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
    }
    /**
     * 验证输入验证码
     * @param params.token 图形验证码token
     * @param params.key 用户输入值
     */
    async verifyCaptchaData(params) {
        return this.request(consts_1.ApiUrls.VERIFY_CAPTCHA_DATA_URL, {
            method: 'POST',
            withBasicAuth: true,
            body: params,
        });
    }
    /**
     * 获取小程序扫码资源
     * @param {GetMiniProgramCodeRequest}params
     * @param {Promise<GetMiniProgramCodeResponse>}
     */
    async getMiniProgramQrCode(params) {
        return this.request(consts_1.ApiUrls.GET_MINIPROGRAM_QRCODE, {
            method: 'POST',
            body: params,
        });
    }
    /**
     * mini-program scan code status
     * @returns
     */
    async getMiniProgramQrCodeStatus(params) {
        return this.request(consts_1.ApiUrls.GET_MINIPROGRAM_QRCODE_STATUS, {
            method: 'POST',
            body: params,
        });
    }
    static parseParamsToSearch(params) {
        for (let key in params) {
            if (!params[key]) {
                delete params[key];
            }
        }
        const searchParams = new URLSearchParams(params);
        return searchParams.toString();
    }
}
exports.Auth = Auth;

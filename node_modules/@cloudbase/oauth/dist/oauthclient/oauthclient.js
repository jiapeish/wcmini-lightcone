"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuth2Client = exports.LocalCredentials = exports.generateRequestId = exports.toResponseError = void 0;
const consts_1 = require("./consts");
const uuid_1 = require("../utils/uuid");
const base64_1 = require("../utils/base64");
const promise_1 = require("../utils/promise");
const RequestIdHeaderName = 'x-request-id';
const DeviceIdHeaderName = 'x-device-id';
const DeviceIdSectionName = 'device_';
const toResponseError = (error, options) => {
    let responseError;
    const formatOptions = options || {};
    if (error instanceof Error) {
        responseError = {
            error: formatOptions.error || consts_1.ErrorType.LOCAL,
            error_description: formatOptions.error_description || error.message,
            error_uri: formatOptions.error_uri,
            details: formatOptions.details || error.stack,
        };
    }
    else {
        const formatError = error || {};
        responseError = {
            error: formatOptions.error || formatError.error || consts_1.ErrorType.LOCAL,
            error_description: formatOptions.error_description || formatError.error_description,
            error_uri: formatOptions.error_uri || formatError.error_uri,
            details: formatOptions.details || formatError.details,
        };
    }
    return responseError;
};
exports.toResponseError = toResponseError;
/**
 * Generate request id.
 * @return {string}
 */
function generateRequestId() {
    return (0, uuid_1.uuidv4)();
}
exports.generateRequestId = generateRequestId;
/**
 * Check if credentials is expired.
 * @param {Credentials} credentials
 * @return {boolean}
 */
function isCredentialsExpired(credentials) {
    let isExpired = true;
    if (credentials && credentials.expires_at && credentials.access_token) {
        isExpired = credentials.expires_at < new Date();
    }
    return isExpired;
}
/**
 * Local credentials.
 * Local credentials, with memory cache and storage cache.
 * If the memory cache expires, the storage cache is automatically loaded.
 */
class LocalCredentials {
    /**
     * constructor
     * @param {LocalCredentialsOptions} options
     */
    constructor(options) {
        this._credentials = null;
        this._promiseOnce = new promise_1.PromiseOnce();
        this._tokenSectionName = options.tokenSectionName;
        this._storage = options.storage;
    }
    /**
     * setCredentials Provides an alternative fetch api request implementation with auth credentials
     * @param {Credentials} credentials
     */
    async setCredentials(credentials) {
        if (credentials && credentials.expires_in) {
            credentials.expires_at = new Date(Date.now() + (credentials.expires_in - 30) * 1000);
            if (this._storage) {
                const tokenStr = JSON.stringify(credentials);
                await this._storage.setItem(this._tokenSectionName, tokenStr);
            }
            this._credentials = credentials;
        }
        else {
            if (this._storage) {
                await this._storage.removeItem(this._tokenSectionName);
            }
            this._credentials = null;
        }
    }
    /**
     * Get credentials.
     * @return {Promise<Credentials>}
     */
    async getCredentials() {
        return this._promiseOnce.run('getCredentials', async () => {
            if (isCredentialsExpired(this._credentials)) {
                this._credentials = await this._getStorageCredentials();
            }
            return this._credentials;
        });
    }
    /**
     * Get storage credentials.
     */
    async _getStorageCredentials() {
        return this._promiseOnce.run('_getStorageCredentials', async () => {
            let credentials = null;
            const tokenStr = await this._storage.getItem(this._tokenSectionName);
            if (tokenStr !== undefined && tokenStr !== null) {
                try {
                    credentials = JSON.parse(tokenStr);
                    if (credentials && credentials.expires_at) {
                        credentials.expires_at = new Date(credentials.expires_at);
                    }
                }
                catch (error) {
                    await this._storage.removeItem(this._tokenSectionName);
                    credentials = null;
                }
            }
            return credentials;
        });
    }
}
exports.LocalCredentials = LocalCredentials;
/**
 * OAuth2Client
 */
class OAuth2Client {
    /**
     * constructor
     * @param {OAuth2ClientOptions} options
     */
    constructor(options) {
        this._promiseOnce = new promise_1.PromiseOnce();
        this._retry = this._formatRetry(options.retry, OAuth2Client._defaultRetry);
        this._baseRequest = options.request;
        if (!options.clientSecret) {
            options.clientSecret = "";
        }
        if (options.clientId !== '') {
            this._basicAuth = "Basic " + (0, base64_1.weBtoa)(options.clientId + ":" + options.clientSecret);
        }
        this._tokenInURL = options.tokenInURL;
        this._headers = options.headers;
        // @ts-ignore
        this._storage = options.storage || defaultStorage;
        this._localCredentials = new LocalCredentials({
            tokenSectionName: 'credentials_',
            storage: this._storage,
        });
        this._refreshTokenFunc =
            options.refreshTokenFunc || this._defaultRefreshTokenFunc;
    }
    /**
     * setCredentials Provides an alternative fetch api request implementation with auth credentials
     * @param {Credentials} credentials
     * @return {Promise<void>}
     */
    setCredentials(credentials) {
        return this._localCredentials.setCredentials(credentials);
    }
    /**
     * getAccessToken return a validate access token
     */
    async getAccessToken() {
        const credentials = await this._getCredentials();
        if (credentials && credentials.access_token) {
            return Promise.resolve(credentials.access_token);
        }
        return Promise.reject({ error: consts_1.ErrorType.UNAUTHENTICATED });
    }
    /**
     * getScope return a validate access token
     */
    async getScope() {
        let credentials = await this._localCredentials.getCredentials();
        if (credentials == null) {
            return this._unAuthenticatedError("credentials not found");
        }
        return credentials.scope;
    }
    /**
     * request http like simple fetch api, exp:request('/v1/user/me', {withCredentials:true})
     * @param {string} url
     * @param {AuthClientRequestOptions} options
     */
    async request(url, options) {
        if (!options) {
            options = {};
        }
        const retry = this._formatRetry(options.retry, this._retry);
        options.headers = options.headers || {};
        if (this._headers) {
            options.headers = {
                ...this._headers,
                ...options.headers,
            };
        }
        if (!options.headers[RequestIdHeaderName]) {
            options.headers[RequestIdHeaderName] = generateRequestId();
        }
        if (!options.headers[DeviceIdHeaderName]) {
            const deviceId = await this._getDeviceId();
            options.headers[DeviceIdHeaderName] = deviceId;
        }
        if (options && options.withBasicAuth && this._basicAuth) {
            options.headers['Authorization'] = this._basicAuth;
        }
        if (options && options.withCredentials) {
            const credentials = await this._getCredentials();
            if (credentials) {
                if (this._tokenInURL) {
                    if (url.indexOf('?') < 0) {
                        url += '?';
                    }
                    url += 'access_token=' + credentials.access_token;
                }
                else {
                    options.headers['Authorization'] =
                        credentials.token_type + ' ' + credentials.access_token;
                }
            }
        }
        let response;
        const maxRequestTimes = retry + 1;
        for (let requestTime = 0; requestTime < maxRequestTimes; requestTime++) {
            try {
                response = await this._baseRequest(url, options);
                break;
            }
            catch (responseError) {
                if (options.withCredentials && responseError && responseError.error === consts_1.ErrorType.UNAUTHENTICATED) {
                    await this.setCredentials(null);
                    return Promise.reject(responseError);
                }
                if (requestTime === retry ||
                    !responseError ||
                    responseError.error !== 'unreachable') {
                    return Promise.reject(responseError);
                }
            }
            await this._sleep(OAuth2Client._retryInterval);
        }
        return response;
    }
    /**
     * Check retry value.
     * @param {number} retry
     * @return {number}
     */
    _checkRetry(retry) {
        let responseError = null;
        if (typeof retry !== 'number' ||
            retry < OAuth2Client._minRetry ||
            retry > OAuth2Client._maxRetry) {
            responseError = {
                error: consts_1.ErrorType.UNREACHABLE,
                error_description: 'wrong options param: retry',
            };
        }
        if (responseError) {
            throw responseError;
        }
        return retry;
    }
    /**
     * Format retry value.
     * @param {number} retry
     * @param {number} defaultVale
     * @return {number}
     */
    _formatRetry(retry, defaultVale) {
        if (typeof retry === 'undefined') {
            return defaultVale;
        }
        else {
            return this._checkRetry(retry);
        }
    }
    /**
     * Sleep.
     * @param {number} ms
     * @return {Promise<void>}
     */
    async _sleep(ms) {
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve();
            }, ms);
        });
    }
    /**
     * Refresh expired token.
     * @param {Credentials} credentials
     * @return {Promise<Credentials>}
     */
    async _refreshToken(credentials) {
        return this._promiseOnce.run('_refreshToken', async () => {
            if (!credentials || !credentials.refresh_token) {
                return this._unAuthenticatedError('no refresh token found in credentials');
            }
            try {
                const newCredentials = await this._refreshTokenFunc(credentials.refresh_token);
                await this._localCredentials.setCredentials(newCredentials);
                return newCredentials;
            }
            catch (error) {
                if (error.error === consts_1.ErrorType.INVALID_GRANT) {
                    await this._localCredentials.setCredentials(null);
                    return this._unAuthenticatedError(error.error_description);
                }
                return Promise.reject(error);
            }
        });
    }
    /**
     * anonymous signIn
     * @param {Credentials} credentials
     * @return {Promise<Credentials>}
     */
    async _anonymousSignIn(credentials) {
        return this._promiseOnce.run('_anonymous', async () => {
            if (!credentials || credentials.scope !== 'anonymous') {
                return this._unAuthenticatedError('no anonymous in credentials');
            }
            try {
                const newCredentials = await this.request('/auth/v1/signin/anonymously', {
                    method: 'POST',
                    withBasicAuth: true,
                    body: {}
                });
                await this._localCredentials.setCredentials(newCredentials);
                return newCredentials;
            }
            catch (error) {
                if (error.error === consts_1.ErrorType.INVALID_GRANT) {
                    await this._localCredentials.setCredentials(null);
                    return this._unAuthenticatedError(error.error_description);
                }
                return Promise.reject(error);
            }
        });
    }
    /**
     * Default refresh token function.
     * @param {string} refreshToken
     * @return {Promise<Credentials>}
     */
    _defaultRefreshTokenFunc(refreshToken) {
        if (refreshToken === undefined || refreshToken === '') {
            return this._unAuthenticatedError('refresh token not found');
        }
        return this.request('/auth/v1/token', {
            method: 'POST',
            withBasicAuth: true,
            body: {
                grant_type: 'refresh_token',
                refresh_token: refreshToken,
            },
        });
    }
    /**
     * Get credentials.
     */
    async _getCredentials() {
        let credentials = await this._localCredentials.getCredentials();
        if (credentials == null) {
            return this._unAuthenticatedError("credentials not found");
        }
        if (isCredentialsExpired(credentials)) {
            if (credentials && credentials.scope === 'anonymous') {
                credentials = await this._anonymousSignIn(credentials);
            }
            else {
                credentials = await this._refreshToken(credentials);
            }
        }
        return credentials;
    }
    /**
     * Get deviceId
     */
    async _getDeviceId() {
        if (this._deviceID) {
            return this._deviceID;
        }
        let deviceId = await this._storage.getItem(DeviceIdSectionName);
        if (!(typeof deviceId === 'string' &&
            deviceId.length >= 16 &&
            deviceId.length <= 48)) {
            deviceId = (0, uuid_1.uuidv4)();
            await this._storage.setItem(DeviceIdSectionName, deviceId);
        }
        this._deviceID = deviceId;
        return deviceId;
    }
    /**
     * Generate unAuthenticated error.
     * @param {string} err
     * @return {Promise<T>}
     */
    _unAuthenticatedError(err) {
        return Promise.reject({
            error: consts_1.ErrorType.UNAUTHENTICATED,
            error_description: err,
        });
    }
}
OAuth2Client._defaultRetry = 2;
OAuth2Client._minRetry = 0;
OAuth2Client._maxRetry = 5;
OAuth2Client._retryInterval = 1000;
exports.OAuth2Client = OAuth2Client;

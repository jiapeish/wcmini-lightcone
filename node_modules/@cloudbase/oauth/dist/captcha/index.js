"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Captcha = exports.getCaptcha = void 0;
const consts_1 = require("../auth/consts");
const internal_1 = require("../app/internal");
const mp_1 = require("../utils/mp");
function getCaptcha(app, opts) {
    return (0, internal_1._getComponent)(app, 'captcha', () => {
        const initOpts = {
            ...app.options.captchaOptions,
            clientId: app.options.clientId,
            request: app.options.request,
            storage: app.options.storage,
        };
        if (opts && opts.request) {
            initOpts.request = opts.request;
        }
        return new Captcha(initOpts);
    });
}
exports.getCaptcha = getCaptcha;
class Captcha {
    /**
     * constructor
     * @param {CaptchaOptions} opts
     */
    constructor(opts) {
        this.config = opts;
        this.tokenSectionName = `captcha_${opts.clientId || ''}`;
    }
    /**
     * request http like simple fetch api, exp:request('/v1/user/me', {withCredentials:true})
     * @param {string} url
     * @param {AuthClientRequestOptions} options
     */
    async request(url, options) {
        if (!options) {
            options = {};
        }
        if (!options.method) {
            options.method = 'GET';
        }
        const state = `${options.method}:${url}`;
        let reqURL = url;
        if (options.withCaptcha) {
            reqURL = await this.appendCaptchaTokenToURL(url, state, false);
        }
        let resp;
        try {
            resp = await this.config.request(reqURL, options);
        }
        catch (err) {
            if (err.error === consts_1.ErrorType.CAPTCHA_REQUIRED || err.error === consts_1.ErrorType.CAPTCHA_INVALID) {
                url = await this.appendCaptchaTokenToURL(url, state, err.error === consts_1.ErrorType.CAPTCHA_INVALID);
                return this.config.request(url, options);
            }
            return Promise.reject(err);
        }
        return resp;
    }
    /**
     * getCaptchaToken 获取captchaToken
     */
    async getCaptchaToken(forceNewToken, state) {
        if (!forceNewToken) {
            // 如果本地存在，则直接返回
            const captchaToken = await this.findCaptchaToken();
            if (captchaToken) {
                return captchaToken;
            }
        }
        let captchaTokenResp;
        if ((0, mp_1.isMp)() || (0, mp_1.isInMpWebView)()) {
            /**
             * https://iwiki.woa.com/p/4010699417
             */
            const captchaDataResp = await this.config.request(consts_1.ApiUrls.CAPTCHA_DATA_URL, {
                method: 'POST',
                body: {
                    state,
                    redirect_uri: '',
                },
                withBasicAuth: true,
                withCredentials: false,
            });
            captchaTokenResp = {
                url: `${captchaDataResp.data}?state=${encodeURIComponent(state)}&token=${captchaDataResp.token}`,
            };
        }
        else {
            const redirect_uri = `${window.location.origin + window.location.pathname}?__captcha=on`;
            captchaTokenResp = await this.config.request(consts_1.ApiUrls.GET_CAPTCHA_URL, {
                method: 'POST',
                body: {
                    client_id: this.config.clientId,
                    redirect_uri,
                    state,
                },
                withBasicAuth: true,
            });
        }
        const captchaToken = captchaTokenResp.captcha_token
            ? {
                captcha_token: captchaTokenResp.captcha_token,
                expires_in: captchaTokenResp.expires_in,
            }
            : await this.config.openURIWithCallback(captchaTokenResp.url, {
                width: '355px',
                height: '355px',
            });
        await this.saveCaptchaToken({
            captcha_token: captchaToken.captcha_token,
            expires_in: Number(captchaToken.expires_in),
        });
        return captchaToken.captcha_token;
    }
    async appendCaptchaTokenToURL(url, state, forceNewToken) {
        const captchaToken = await this.getCaptchaToken(forceNewToken, state);
        if (url.indexOf('?') > 0) {
            url += `&captcha_token=${captchaToken}`;
        }
        else {
            url += `?captcha_token=${captchaToken}`;
        }
        return url;
    }
    async saveCaptchaToken(token) {
        token.expires_at = new Date(Date.now() + (token.expires_in - 10) * 1000);
        const tokenStr = JSON.stringify(token);
        await this.config.storage.setItem(this.tokenSectionName, tokenStr);
    }
    async findCaptchaToken() {
        const tokenStr = await this.config.storage.getItem(this.tokenSectionName);
        if (tokenStr !== undefined && tokenStr !== null) {
            try {
                const captchaToken = JSON.parse(tokenStr);
                if (captchaToken && captchaToken.expires_at) {
                    captchaToken.expires_at = new Date(captchaToken.expires_at);
                }
                const isExpired = captchaToken.expires_at < new Date();
                if (isExpired) {
                    return null;
                }
                return captchaToken.captcha_token;
            }
            catch (error) {
                await this.config.storage.removeItem(this.tokenSectionName);
                return null;
            }
        }
        return null;
    }
}
exports.Captcha = Captcha;

import { scanCode } from './scanCode/scanCode';
import { ACTIONS_KEY } from '../../common/constants';
import { callWedaApiFn } from '../../common/models';
import { isObject, isPlainObject } from '../../vender';
import { getEnumValue } from '../../common/utils';
const OFFICIAL_LIB_KEY = `@weapps-materials-main-gsd-h5-react`;
/**
 * 将sdk挂在到app对象上，actions 分app 和 wx 挂载app 小程序的api
 * @param sdks
 * @returns
 */
export function createWebActionsAPI(app, sdks, options) {
    const actions = {};
    const { processAction = function (name, action) {
        return action;
    }, } = options || {};
    Object.keys(sdks).forEach((item) => {
        let action = sdks[item];
        switch (item) {
            case ACTIONS_KEY.showToast: {
                action = function (obj) {
                    if (obj?.title && obj.title.length > 7) {
                        console.warn("showToast->title'length cannot exceed 7");
                    }
                    if (obj.icon === 'error' && !obj.image) {
                        return sdks[item]({
                            ...obj,
                            image: 'data:image/svg+xml,%3Csvg%20width%3D%22120%22%20height%3D%22120%22%20viewBox%3D%220,0,24,24%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%3Cpath%20d%3D%22M12%2010.586l5.657-5.657%201.414%201.414L13.414%2012l5.657%205.657-1.414%201.414L12%2013.414l-5.657%205.657-1.414-1.414L10.586%2012%204.929%206.343%206.343%204.93%2012%2010.586z%22%20fill-rule%3D%22evenodd%22%20fill%3D%22white%22%2F%3E%3C%2Fsvg%3E',
                        });
                    }
                    return sdks[item](obj);
                };
                break;
            }
            case ACTIONS_KEY.showModal: {
                action = function (params) {
                    const showModal = window[OFFICIAL_LIB_KEY]?.actions?.showModal;
                    if (!app?.__internal__?.isMobile?.() && showModal) {
                        return showModal({ data: params });
                    }
                    else {
                        return sdks[item](params);
                    }
                };
                break;
            }
            case ACTIONS_KEY.scanCode: {
                action = (options) => {
                    if (!options || (!options.success && !options.fail && !options.complete)) {
                        return new Promise((resolve, reject) => {
                            scanCode({
                                ...options,
                                success: resolve,
                                fail: reject,
                            });
                        });
                    }
                    scanCode(options);
                };
                break;
            }
            case ACTIONS_KEY.openLocation: {
                action = () => { };
                break;
            }
        }
        // 只添加action相关的
        if (item in ACTIONS_KEY) {
            actions[item] = processAction(item, action);
        }
    });
    actions[ACTIONS_KEY.callProcess] = function ({ processKey, ProcessKey, startParams, StartParams }) {
        return callWedaApiFn('StartProcessWithParams', {
            ProcessKey: processKey || ProcessKey,
            TriggerType: 1,
            StartParams: startParams || StartParams || [],
        });
    };
    actions[ACTIONS_KEY.callWorkflow] = function ({ flowId, params = {}, debugEnabled = false }) {
        return callWedaApiFn('StartFlowInstance', {
            FlowId: flowId,
            Params: params,
            DebugEnabled: debugEnabled,
        });
    };
    actions[ACTIONS_KEY.callPhone] = function ({ tel }) {
        return (location.href = `tel:${tel}`);
    };
    actions[ACTIONS_KEY.requestSubscribeMessage] = () => { };
    actions[ACTIONS_KEY.reserveChannelsLive] = () => { };
    actions[ACTIONS_KEY.openChannelsUserProfile] = () => { };
    actions[ACTIONS_KEY.openChannelsLive] = () => { };
    actions[ACTIONS_KEY.openChannelsEvent] = () => { };
    actions[ACTIONS_KEY.openChannelsActivity] = () => { };
    actions[ACTIONS_KEY.getChannelsLiveNoticeInfo] = () => { };
    actions[ACTIONS_KEY.getChannelsLiveInfo] = () => { };
    actions[ACTIONS_KEY.setClipboardData] = async ({ data, success = (res) => { }, fail = (err) => { }, complete = (err) => { }, }) => {
        let res = {};
        try {
            /**
             * 异步操作中 document 失焦
             * 可能导致失败
             */
            if (document.execCommand) {
                const el = document.createElement('textarea');
                document.body.appendChild(el);
                // 隐藏此输入框
                el.style.position = 'fixed';
                el.style.clip = 'rect(0 0 0 0)';
                el.style.top = '10px';
                // 赋值
                el.value = data;
                // 选中
                el.focus();
                el.select();
                // 复制
                document.execCommand('copy');
                // 移除输入框
                el.remove();
            }
            else {
                // if (false) {
                // clipboard api 复制
                navigator.clipboard.writeText(data);
            }
            res = { data };
            success(res);
        }
        catch (e) {
            res = e;
            fail(res);
            throw e;
        }
        finally {
            complete(res);
        }
    };
    actions[ACTIONS_KEY.exportData] = async ({ data, fileName = 'download', fileType = 'csv', options }) => {
        const INVALID_PARAMS = 'InvalidParams';
        if (!Array.isArray(data) && !isPlainObject(data)) {
            const error = new Error(`数据格式为对象数组 Object[]，如[{name: 'sam', age: 18}]`);
            error.code = INVALID_PARAMS;
            throw error;
        }
        if (!['csv', 'xlsx'].includes(fileType)) {
            const error = new Error('fileType 仅支持 csv, xlsx');
            error.code = INVALID_PARAMS;
            throw error;
        }
        const rowData = convertToRowBased(data);
        switch (fileType) {
            case 'csv':
                return saveAs(new Blob([await getDataAsCSV(rowData)], {
                    type: 'text/csv;charset=utf-8;',
                }), `${fileName}.${fileType}`);
            case 'json':
                return saveAs(new Blob([JSON.stringify(data, null, 2)], {
                    type: 'data:text/json',
                }), `${fileName}.${fileType}`);
            case 'xlsx': {
                const XLSX = await (process.env.compileTool === 'rollup'
                    ? require('xlsx')
                    : import(/* webpackChunkName: "extra-package" */ 'xlsx'));
                const { sheetName = 'Sheet1' } = options || {};
                const sanitizedData = sanitizeTabularDataForExcel(rowData);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, XLSX.utils.aoa_to_sheet(sanitizedData), sheetName);
                return saveAs(new Blob([
                    s2ab(XLSX.write(workbook, {
                        bookType: 'xlsx',
                        type: 'binary',
                    })),
                ], {
                    type: 'application/octet-stream',
                }), `${fileName}.${fileType}`);
            }
            default: {
                const error = new Error('fileType 仅支持 csv, xlsx');
                error.code = INVALID_PARAMS;
                throw error;
            }
        }
    };
    actions[ACTIONS_KEY.getEnumValue] = (params) => {
        return getEnumValue(params, app?.__internal__?.$w?.app);
    };
    actions[ACTIONS_KEY.setTitle] = (newTitle) => new Promise((res, rej) => {
        try {
            document.title = newTitle;
            res(undefined);
        }
        catch (e) {
            rej(e);
        }
    });
    return actions;
}
function s2ab(s) {
    let buf;
    let view;
    if ('undefined' !== typeof ArrayBuffer) {
        buf = new ArrayBuffer(s.length);
        view = new Uint8Array(buf);
    }
    else {
        buf = new Array(s.length);
        view = buf;
    }
    for (let i = 0; i !== s.length; ++i) {
        view[i] = s.charCodeAt(i) & 0xff;
    }
    return buf;
}
async function getDataAsCSV(rowData) {
    const convertData = sanitizeTabularDataForExcel(rowData);
    const papa = await (process.env.compileTool === 'rollup'
        ? require('papaparse')
        : import(/* webpackChunkName: "extra-package" */ 'papaparse'));
    return papa.unparse(convertData);
}
function sanitizeTabularDataForExcel(e) {
    return e
        .map((e) => e.map((e) => (isObject(e) ? JSON.stringify(e) : e)))
        .map((e) => e.map((e) => {
        if ('string' === typeof e && e.trim()) {
            const t = e.trim();
            if (['=', '+', '-', '@'].includes(t.charAt(0))) {
                const n = /^-[$\\u20ac]?[\d,.]+$/g;
                return t.match(n) ? t : `'${e}`;
            }
        }
        return e;
    }));
}
function convertToRowBased(data) {
    if (Array.isArray(data)) {
        if (!data.length) {
            return [[]];
        }
        if (Array.isArray(data[0])) {
            return data;
        }
        const headerSet = new Set();
        data.forEach((item) => {
            Object.keys(item).forEach((key) => {
                headerSet.add(key);
            });
        });
        if (!headerSet.size) {
            return [[]];
        }
        const heaners = Array.from(headerSet);
        const res = [heaners];
        data.forEach((item) => {
            res.push(heaners.map((key) => item[key]));
        });
        return res;
    }
    const headers = Object.keys(data);
    if (!headers.length) {
        return [[]];
    }
    const res = [headers];
    const n = data[headers[0]].length;
    for (let index = 0; index < n; index++) {
        res.push(headers.map((key) => data[key][index]));
    }
    return res;
}
function saveAs(blob, fileName) {
    const name = fileName || blob.name || 'download';
    const a = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
    a.download = name;
    a.rel = 'noopener'; // tabnabbing
    a.href = URL.createObjectURL(blob);
    /**
     * file-saver 这个包用了 dispatchEvent 的方式来触发 click
     * 因为不是所有浏览器都支持
     * 但 caniuse 查看，基本上能支持 proxy 的都支持了
     * 直接 a.click 简单实现
     */
    a.click();
    setTimeout(() => {
        URL.revokeObjectURL(a.href);
    }, 4e4); // 40s
}

// @ts-nocheck
import React from 'react';
import { useMemo, useRef, useEffect, useImperativeHandle, useState, useCallback, forwardRef } from 'react';
import * as ReactDOM from 'react-dom';
import { BrowserMultiFormatReader, NotFoundException, BarcodeFormat, DecodeHintType } from '@zxing/library';
function CloseButton({ onClick }) {
    return (React.createElement("div", { className: "weapp-scancode-close-button", "aria-label": "close modal", onClick: onClick },
        React.createElement("svg", { width: "12px", height: "12px", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
            React.createElement("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.5348 2.04999L7.9998 6.58499L3.4638 2.04999L2.0498 3.46499L6.5858 8.00099L2.0498 12.536L3.4638 13.95L7.9998 9.41499L12.5348 13.95L13.9498 12.536L9.4138 8.00099L13.9498 3.46499L12.5348 2.04999Z", fill: "currentColor" }))));
}
export const FORMAT = {
    0: { scanType: 'AZTEC', wxtype: null },
    1: { scanType: 'CODABAR', wxtype: 'barCode' },
    2: { scanType: 'CODE_39', wxtype: 'barCode' },
    3: { scanType: 'CODE_93', wxtype: 'barCode' },
    4: { scanType: 'CODE_128', wxtype: 'barCode' },
    5: { scanType: 'DATA_MATRIX', wxtype: 'qrCode' },
    6: { scanType: 'EAN_8', wxtype: 'barCode' },
    7: { scanType: 'EAN_13', wxtype: 'barCode' },
    8: { scanType: 'ITF', wxtype: 'barCode' },
    9: { scanType: 'MAXICODE', wxtype: null },
    10: { scanType: 'PDF_417', wxtype: 'qrCode' },
    11: { scanType: 'QR_CODE', wxtype: 'qrCode' },
    12: { scanType: 'RSS_14', wxtype: 'barCode' },
    13: { scanType: 'RSS_EXPANDED', wxtype: 'barCode' },
    14: { scanType: 'UPC_A', wxtype: 'barCode' },
    15: { scanType: 'UPC_E', wxtype: 'barCode' },
    16: { scanType: 'UPC_EAN_EXTENSION', wxtype: 'barCode' },
};
function wechatLikeResult(zxingResult) {
    const wechatResult = {
        result: zxingResult.text || zxingResult.result,
        scanType: FORMAT[zxingResult.format].wxtype,
    };
    return wechatResult;
}
let HINTS = null;
// 使用时再赋值
const getHints = () => {
    if (HINTS)
        return HINTS;
    HINTS = new Map();
    const formats = [
        BarcodeFormat.QR_CODE,
        BarcodeFormat.UPC_A,
        BarcodeFormat.UPC_E,
        BarcodeFormat.EAN_8,
        BarcodeFormat.EAN_13,
        BarcodeFormat.CODE_39,
        BarcodeFormat.CODE_93,
        BarcodeFormat.CODE_128,
        BarcodeFormat.DATA_MATRIX,
        BarcodeFormat.PDF_417,
    ];
    HINTS.set(DecodeHintType.POSSIBLE_FORMATS, formats);
};
// eslint-disable-next-line prefer-arrow-callback
const Codescanner = forwardRef(function CodeScanner({ events = {}, closeScanCode, scanType, onInit }, fref) {
    const ref = useRef();
    const { fail = () => { }, success = () => { }, complete = () => { } } = events;
    const inited = useRef(false);
    const hints = getHints();
    const codeReader = new BrowserMultiFormatReader(hints);
    const start = async () => {
        setTimeout(() => {
            // try harder after 5 sceonds
            codeReader.hints?.set?.(DecodeHintType.TRY_HARDER, true);
            codeReader.timeBetweenDecodingAttempts = 1500;
        }, 5000);
        const devices = await codeReader.listVideoInputDevices();
        if (devices.length) {
            try {
                let constraints = { video: { facingMode: 'environment' } };
                const lowerCaseUa = navigator?.userAgent.toLowerCase();
                if (lowerCaseUa.includes('huawei')) {
                    /**
                     * 垃圾华为的API有坑
                     * 1. getUserMedia facingMode 参数是坏的
                     * 2. 多摄像头会返回多个devices而且其中有几个是坏的， 比如后面有4个摄像头，总共5个摄像头的设备返回8个devices 但是有两个是坏的，前置有2个，后置有4个
                     * 3. 主摄顺序不固定
                     * 4. 拿MediaTrack 要一个个调否则会抛错
                     * 5. 企业微信之类的特定webview环境下即使获取了mediatrack device的label属性也是空串
                     * 6. 某些机型（目前看到的是p40)某些webview 获取mediaTrack会直接闪退
                     *
                     * 1. 轮询（因为4）获取所有videoinput的mediaTrack 中通过getSettings 拿到 facingMode 判断前后摄像头
                     * 2. 轮询的时候已经try catch 排掉了
                     * 3. 据说(https://www.reddit.com/r/javascript/comments/8eg8w5/choosing_cameras_in_javascript_with_the/)最后一个是主摄像头的概率很大，从后往前读读到focusDistance.min > 0.05的停， 都没有就用最后一个后置
                     */
                    if (/els-an00/.test(lowerCaseUa) && /wxwork|micromes/.test(lowerCaseUa)) {
                        // p40 闪退直接不支持
                        fail(new Error('当前机型的设备暂不支持扫码功能'));
                    }
                    const environmentDevicesList = [];
                    for (const device of devices) {
                        try {
                            const stream = await window.navigator.mediaDevices.getUserMedia({
                                video: {
                                    deviceId: { exact: device.deviceId },
                                },
                            });
                            const tracks = await stream.getVideoTracks();
                            tracks.forEach((track) => {
                                const capablities = track.getCapabilities();
                                const settings = track.getSettings();
                                if (settings.facingMode === 'environment') {
                                    environmentDevicesList.push({
                                        ...device,
                                        focusDistance: capablities.focusDistance,
                                    });
                                }
                                track.stop();
                            });
                        }
                        catch (err) {
                            // 忽略
                        }
                    }
                    if (environmentDevicesList.length > 0) {
                        let deviceId = null;
                        for (let i = environmentDevicesList.length - 1; i >= 0; i--) {
                            const device = environmentDevicesList[i];
                            if (device.focusDistance.min > 0.05) {
                                deviceId = device.deviceId;
                                break;
                            }
                        }
                        if (deviceId === null) {
                            deviceId = environmentDevicesList[environmentDevicesList.length - 1].deviceId;
                        }
                        constraints = {
                            video: {
                                deviceId: {
                                    exact: deviceId,
                                },
                            },
                        };
                    }
                }
                await codeReader.decodeFromConstraints(constraints, ref.current, (result, err) => {
                    if (!inited.current) {
                        inited.current = true;
                        onInit();
                    }
                    if (result) {
                        if (scanType.includes(FORMAT[result.format].wxtype)) {
                            success(wechatLikeResult(result));
                            complete();
                            closeScanCode();
                        }
                    }
                    if (err && !err instanceof NotFoundException) {
                        fail(err);
                        complete();
                    }
                });
            }
            catch (err) {
                fail(err);
            }
        }
        else {
            fail(new Error('No camera detect'));
            complete();
        }
    };
    const stop = () => {
        codeReader.reset();
    };
    useImperativeHandle(fref, () => ({
        start,
        stop,
    }));
    useEffect(() => {
        start().catch(fail);
        return () => {
            stop();
        };
    }, []);
    return (React.createElement(React.Fragment, null,
        React.createElement("video", { autoPlay: true, muted: true, playsInline: true, ref: ref, id: "weapp-scancode-video" })));
});
function fileToImage(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = async (ev) => {
            const img = new Image();
            img.src = ev.target.result;
            resolve(img);
        };
        reader.onerror = reject;
    });
}
export const SCAN_CODE_STATE = 'scan-code-modal';
export let SACN_CODE_MODAL_VISIBLE = 0;
export default function ScanCode({ root, options }) {
    const { onlyFromCamera, scanType, success: successCallback, fail, complete, enableDefaultBehavior } = options;
    const ref = useRef();
    const closeScanCode = useCallback(() => {
        ref.current?.stop?.();
        ReactDOM.render(null, root);
    }, []);
    useEffect(() => {
        SACN_CODE_MODAL_VISIBLE += 1;
        // 覆盖一次返回按键为关闭
        if (window?.history.state?.SCANCODE !== SCAN_CODE_STATE) {
            window?.history.pushState({ SCANCODE: SCAN_CODE_STATE }, null);
        }
        const onPopState = (e) => {
            closeScanCode();
        };
        window.addEventListener('popstate', onPopState);
        return () => {
            SACN_CODE_MODAL_VISIBLE -= 1;
            // 兜底进行路由恢复
            /**
             * 发现
             * 当页面栈为 [3,1] 时，在1处 navigateback() + navigateTo(2) = [3], unmout 1, mout2 , unmout2, mout3
             * - back in
             * - nav in
             * - unmout 1, mout2 , unmout2, mout3
             * 当页面栈为 [3,1] 时，在1处 navigateTo(2) + navigateback() = [3，1], unmout 1, mout2 2, unmout2, mout1
             * - nav in
             * - unmout 1
             * - back in
             * - mount 2
             * - unmout2, mout1
             *
             * 原因未知，通过延时防止路由同时变化，更优解为串行路由
             */
            setTimeout(() => {
                if (window?.history.state?.SCANCODE === SCAN_CODE_STATE && SACN_CODE_MODAL_VISIBLE === 0) {
                    window?.history.back();
                }
            }, 0);
            window.removeEventListener('popstate', onPopState);
        };
    }, [closeScanCode]);
    const success = useCallback((res) => {
        const { result } = res;
        if (enableDefaultBehavior) {
            if (/^https?:\/\//.test(result)) {
                window.open(result);
            }
            else {
                window.app.showModal({
                    title: '扫描到以下内容',
                    content: result,
                    showCancel: false,
                    confirmColor: '#006eff',
                });
            }
        }
        successCallback(res);
    });
    const [isCameraInit, setIscameraInit] = useState(false);
    const onInitCamera = () => {
        setIscameraInit(true);
    };
    const [modalErrMessage, setModalErrMessage] = useState('');
    const handleModalClick = () => {
        setModalErrMessage('');
    };
    const fileChanged = async (ev) => {
        const { files } = ev.target;
        if (files.length <= 0)
            return;
        const file = files[0];
        const img = await fileToImage(file);
        const hints = getHints();
        hints.set(DecodeHintType.TRY_HARDER, true);
        const codeReader = new BrowserMultiFormatReader(hints);
        try {
            const result = await codeReader.decodeFromImage(img);
            success(wechatLikeResult(result));
            closeScanCode();
        }
        catch (err) {
            onScanFail(err);
        }
    };
    const scanTypeText = useMemo(() => scanType
        .map((type) => {
        switch (type) {
            case 'qrCode':
                return '二维码';
            case 'barCode':
                return '条码';
            default:
                return type;
        }
    })
        .join(' / '), [scanType]);
    const onScanFail = (err) => {
        if (err instanceof NotFoundException) {
            setModalErrMessage(`未发现${scanTypeText}`);
            setIscameraInit(false);
        }
        else {
            if (err.message === 'Permission denied') {
                setModalErrMessage('请打开相机权限以获取扫码功能');
            }
            else if (err.message === 'No camera detect') {
                setModalErrMessage('未能检测到相机设备');
            }
            else {
                setModalErrMessage(err.message);
            }
        }
        setIscameraInit(false);
        fail(err);
    };
    if (modalErrMessage) {
        return (React.createElement("div", { className: "weapp-scancode-modal", onClick: handleModalClick },
            React.createElement("div", { className: "weapp-scancode-modal-main" },
                React.createElement("div", { className: "weapp-scancode-scan-wrapper" },
                    React.createElement("p", { className: "weapp-scancode-scan-not-found" }, modalErrMessage),
                    React.createElement("p", null, "\u70B9\u51FB\u91CD\u65B0\u626B\u7801")),
                React.createElement(CloseButton, { onClick: closeScanCode }))));
    }
    return (React.createElement("div", { className: "weapp-scancode-modal" },
        React.createElement("div", { className: "weapp-scancode-modal-main" },
            React.createElement(Codescanner, { events: { fail: onScanFail, success, complete }, ref: ref, closeScanCode: closeScanCode, scanType: scanType, onInit: onInitCamera }),
            "(",
            React.createElement(React.Fragment, null,
                React.createElement(CloseButton, { onClick: closeScanCode }),
                React.createElement("div", { className: "weapp-scancode-scan-wrapper" },
                    React.createElement("div", { className: "weapp-scancode-scan-square" },
                        React.createElement("div", { className: "weapp-scancode-scan-bar" })),
                    React.createElement("p", { className: "weapp-scancode-scan-tip" }, isCameraInit ? `扫${scanTypeText}` : '相机调起中'))),
            ")",
            !onlyFromCamera && isCameraInit && (React.createElement("div", { className: "weapp-scancode-img-selector" },
                React.createElement("input", { onChange: fileChanged, type: "file", id: "weapp-scancode-img-picker-input", accept: "image/*", style: { display: 'none' } }),
                React.createElement("label", { htmlFor: "weapp-scancode-img-picker-input", className: "weapp-scancode-img-picker" },
                    React.createElement("span", null,
                        React.createElement("svg", { width: "24px", height: "24px", viewBox: "0 0 24 24", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
                            React.createElement("title", null, "icon/album"),
                            React.createElement("g", { id: "icon/album", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd" },
                                React.createElement("rect", { id: "\u77E9\u5F62", x: "0", y: "0", width: "24", height: "24" }),
                                React.createElement("path", { d: "M21,4 C21.5522847,4 22,4.44771525 22,5 L22,19 C22,19.5522847 21.5522847,20 21,20 L3,20 C2.44771525,20 2,19.5522847 2,19 L2,5 C2,4.44771525 2.44771525,4 3,4 L21,4 Z M20.5,5.5 L3.5,5.5 L3.5,13.932 L8.34720227,9.89314397 C8.69729746,9.60139798 9.19512095,9.58601647 9.56028418,9.84165631 L9.65637439,9.91809179 L14.036,13.86 L16.8907001,11.8207928 C17.2650251,11.5533999 17.7734822,11.5758744 18.1227552,11.8752513 L18.1227552,11.8752513 L20.5,13.913 L20.5,5.5 Z", id: "\u5F62\u72B6\u7ED3\u5408", fill: "#FFFFFF", fillRule: "nonzero" }))))))))));
}
